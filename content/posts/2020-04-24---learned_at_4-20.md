---
title: '배움 정리'
date: '2020-04-24T12:10:32.169Z'
template: 'post'
draft: false
slug: '/posts/learned_4-24/'
category: 'learn'
description: '그간 배움 정리'
tags:
  - 'learn'
---

## 그날그날 배운것들을 기록하자.

하루하루 많은 문제들과 부딪히는데 어찌저찌 해결할때도 있고, 해결하지 못할때도 있다 앞으로도 많은 문제를 만날뿐 아니라 같은 문제들도 만날텐데 같은문제가 생길때 다시 또 헤메지 않기위해 배운것들을 기록하려고 한다.

### git flow

깃플로우는 한번 정리를 했었는데 내용들은 어느정도 알았지만 어찌 사용해야할지 몰랐다. 직접 사용하게 되면서 사용법을 정리해보자.

#### 설치

일단 git-flow 명령어를 사용하기 위해 homebrew를 사용하여 git-flow를 설치한다.

```
brew install git-flow
```

#### 초기설정

flow init -d 명령어는 로컬 저장소에 develop 브랜치를 생성한 뒤 해당 브랜치로 이동한다.

```
git flow init -d
```

#### 명령어

```
git flow <feature | release | hotfix> <start | finish> <branch_name>
```

피쳐 릴리즈 핫픽스는 저번에 정리한 그 내용이다.

#### 사용 예

start: 새로운 브랜치 생성

```
기능 개발 시작
git flow feature start <branch_name>
배포 시작
git flow release start <branch_name>
수정 배포 시작
git flow hotfix start <branch_name>
```

finish: 브랜치 병합 후 해당 브랜치 삭제

```
git flow feature finish <branch_name>
...
```

#### 프로젝트 적용

최초 적용 개발자

```
git clone <remote_url>
git flow init -d
git pusj origin develop
git branch --set-upstream-to=origin/develop develop //타 방법
```

클론하는 개발자

```
git clone <remote_url>
git checkout -b develop origin/develop
git flow init -d
```

#### 플로우 사용

특정기능 개발시

```
git flow feature start <branch_name>
개발 완료 후
git flow feature finish <branch_name>
원격 저장소 반영
git push origin master develop
```

배포시기

```
git flow release start <version_name>
git flow release finish <version_name>
git push origin master
git push --tags
```

### react spring

데이터를 받아서 숫자가 다이나믹하게 또로로로롱 올라가는 기능을 구현하려고 라이브러리를 찾아보다가 react spring이라는 라이브러리를 접하게 되었다. 숫자 카운팅 뿐 아니라 이것저것 동적인 웹을 만들기에 유용한 기능들이 많은 라이브러리였다. 일단 숫자카운팅 기능을 위해 공식문서를 보면서 읽고 적용을 시도해보았다.

```jsx
import { useSpring, animated } from 'react-spring'
...
const props = useSpring({ number: 1 , from: { number:0 }) // 0에서 1까지 점차 올라감
return <animated.span>{props.number}</animated.span> // 에니메이티드로 감싼다
```

0에서 1까지 순차적으로 올라가는 기능인데 소수점까지 카운팅이 되서 원치 않는 기능이 생겼다.

```jsx
<animated.span>{props.number.interpolate(x => x.toFixed(0))}</animated.span>
```

공식문서를 다시 찾아보다가 .interpolate를 써서 자바스크립트의 toFixed를 사용해서 리턴을 해주니 소수점이 해결이 되었다 그러나 카운팅 수가 10만이면 100,000이 아니라 10000 나와서 예쁘지 않았다 그래서 고민을 해보다가 interpolate의 함수안에서 잘 가공하여 리턴해주면 될 것 같아서 시도를 해보았다.

```jsx
<animated.span>
  {props.number.interpolate(x => {
    const a = x.toFixed(0);
    a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  })}
</animated.span>
```

소수점을 짤라서 반올림하고 그 반환값을 스트링화하고 정규식을 활용하여 replace를 해주었더니 원하던 형태로 나왔다.

### 타입스크립트에서 css파일 모듈 import 에러

타입스크립트로 프로젝트를 진행하면서 난감한 문제들을 매일마다 만나고있다. 나를 크게 당황시켰던 에러중 하나가 css파일을 임포트해서 적용을 시켜야하는데 임포트를 하면 에러가 났다. 그래서 처음에 해결방안을 찾아보다가 적용했던 방법은

```js
const styles = require('../assets/css.css');
```

이렇게 변수에 담아서 사용을 했다.  
하지만 그래도 부족했고 import를 하는 방법을 찾아보다가 declaration파일을 작성하는 방법을 찾았다
일단 src디렉토리에 declaration.d.ts 파일을 생성한다

```ts
//declaration.d.ts
declare module '*.scss';
```

이러면 스타일파일을 임포트 했을때 에러가 잡힌다.

### useState에서 함수호출 넣기 함수넣기

```jsx
const [state, setState] = useState(fucn);
```

아직 직접 사용은 안했지만 이것저것 자료를 찾아보다 확인한 내용인데 useState로 상태의 초깃값을 설정할때 함수와 함수호출을 넣어주게되었을때는 함수를 넣어주면 처음 렌더링될때만 함수가 실행되는데 함수호출을 하게되면 리렌더링할때마다 함수가 호출된다고한다. 이건 다음에 한번 실험을 해봐야겠다.

```jsx
const [state, setState] = useState(fucn());
```

### useEffect() 뒷정리 해주고 스크롤 이벤트 감지

스크롤 위치 감지 이벤트발생 기능을 구현하면서도 꽤 내용들이 많이나왔다. 처음에 적용했던 방법은 useEffect에서 윈도우에 스크롤 이벤트를 걸어주고 그스크롤이벤트는 스크롤이 어느정도 내려가면 상태를 바꿔주는 이벤트였다.

```jsx
useEffect(() => {
  window.addEventListener('scroll', listenToScroll);
}, []);

const listenToScroll = () => {
  const winScroll =
    document.body.scrollTop || document.documentElement.scrollTop;
  const height =
    document.documentElement.scrollHeight -
    document.documentElement.clientHeight;

  const scrolled = winScroll / height;

  if (isTop && scrolled < 0.2) {
    setIsTop(false);
  }
  if (!isTop && scrolled > 0.2) {
    setIsTop(true);
  }
};
```

자꾸 근데 상태값을 올바르게 체크못하고 상태값을 계속 바꾸는 상황이 생겨서 고민을 해보다가 처음 window에 이벤트가 걸릴때 그떄의 상태값만 기억하는것처럼 결과가 나와서 여러 방법들을 시도해보았다. 그러다가 찾은 방법

```jsx
useEffect(() => {
  window.addEventListener('scroll', listenToScroll);

  return () => {
    window.removeEventListener('scroll', listenToScroll);
  };
}, [isTop]);
```

상태값이 바뀔때 이벤트를 다시 거는데 뒷정리함수로 리무브이벤트리스너를 해준다. 조금 더 공부하고 이해를 해야할것같은 부분이었다. 뒷정리 함수 내용도 다시 정리해야겠다.

### DOM언마운트 시 애니메이션

상태값에 따라 DOM이 마운트되고 언마운트되는 컴포넌트가 있었는데 애니메이션을 주려고 css animation을 적용시켜서 만들었다. 그런데 마운트시에는 애니메이션이 잘 적용이 되었지만 언마운트때는 DOM자체가 없어지므로 애니메이션이 적용이 안되었다. 그래서 fadeIn과 fadeOut 두 가지의 애니메이션을 만들고 상태값에 따라 각각 다른 애니메이션을 적용해주었으며 부모에서 받은 값으로 그 해당 컴포넌트의 상태값을 컨트롤해주는 방법을 적용시키고 찾아보니 onAnimationEnd라는 속성이 있어서 적용해주었다.

```jsx
//부모의 상태 내려주기
<ScrollTopBtn show={show} />,

//애니메이션 적용 컴포넌트
const ScrollTopBtn = ({ show }: Props) => {
  const [shouldRender, setRender] = useState(show);

  useEffect(() => {
    if (show) setRender(true);
  }, [show]);

  const onAnimationEnd = () => {
    if (!show) setRender(false);
  };

  return (
    shouldRender && (
      <button
        onAnimationEnd={onAnimationEnd}
        style={{
          animation: `${show ? 'fadeIn' : 'fadeOut'} 1s`,
        }}
      >
      </button>
    )
  );
};
```

이제 DOM이 사라질때도 애니메이션이 잘 적용이 되었다.
