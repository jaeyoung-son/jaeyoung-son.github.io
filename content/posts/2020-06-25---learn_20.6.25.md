---
title: '배운내용 열심히 정리하기'
date: '2020-06-258T12:10:32.169Z'
template: 'post'
draft: false
slug: '/posts/learn_20_6_25/'
category: 'learn'
description: '배운내용 열심히 정리하자'
tags:
  - 'learn'
---

## 객체와 스토리지 활용

스토리지에 자바스크립트 객체 형태의 내용을 저장하면 형태가 온전히 유지되지 않고, 문자열 형태로 저장이되어 다시 꺼내서 사용할때 원하는 형태로 사용이 안된다. 예를들어서

```js
const obj = {
  a: 1,
  b: 2,
  c: 3
};

localStorage.setItem('obj',obj);
...
localStorage.getItem('obj')
// {"a":1, "b": 2, "c":3}
```

위와같이 단순 문자열 형태를 띄게 된다. 위와같은 문제를 해결하기위해 자바스크립트에서 JSON.parse 메소드를 제공한다. 객체형태가 스토리지에 저장되었을때 문자열화 되어 사용못하는것을 다시 객체형태로 잡아준다.

```js
const obj = {
  a: 1,
  b: 2,
  c: 3
};

localStorage.setItem('obj',obj);
...

JSON.parse(localStorage.getItem('obj'))
// { a: 1, b: 2, c:3}
JSON.parse(localStorage.getItem('obj')).a
// 1
```

객체화 시켜서 온전한 형태로 사용할 수 있다.

## 배열에서 요소 찾기

원래 배열에서 요소를 찾으려면 전에 정리했던 요소 in 배열 문법을 사용하려고 했는데, in문법을 잘못 이해하고있었다. 배열에서 요소를 찾는 문법이 아니었다. 그래서 다른 방법을 찾아보다가 javascript find 문법을 알아보았다.

```js
arr.find(callback, thisArg);
```

find메서드는 두 개의 인자를 받으며 콜백함수는 세 인자를 받는데, el요소, index, array find함수를 호출한 배열을 받고, thisArg는 콜백이 호출될 떄 this로 사용할 객체이다. 메서드 이름 그대로 find해준다.

```js
const arr = [1, 2, 3, 4, 5];

const result = arr.find(el => el > 3);

console.log(result);
//4
```

결과는 4를 반환하는데 5도 3보다 큰데 4만 반환하는 이유는 find메서드는 주어진 판별 함수를 만족하는 첫 번쨰 요소의 값을 반환한다. 그런 요소가 없다면 Undefined를 반환한다.  
!! 배열 요소가 해당 배열에 존재하는지 확인하고자 한다면 array.indexOf() 또는 array.includes()를 활용할것!  
그래서 나는 해당 배열을 가져와서 find메소드에서 해당 결과값이 참인지 거짓인지 판단해 활용하였다.

## 모달에서 배경 스크롤 잡기

모달을 구현하는데 화면 가운데에 모달이 생기고 배경으로는 dim을 넣어주었다. 모달자체가 내용이 길어서 스크롤이 되었는데 모달의 스크롤이 다 되고나면, 모달뒤의 원래 배경이 스크롤이 되는 현상이 있어서 그것을 막기위해 여러 방버을 찾아보았다. 모달 on 시, 단순히 body의 overflow를 오토로 맞춰주고 스크롤을 막는 방법이 있었는데 그렇게하면 모달이 꺼졌을떄 스크롤이 최상단으로 올라가는 문제가 생겼고, 여러가지 솔루션들이 있었지만 다 적용해도 문제가 생겼다. 그러다가 찾은 방법이다.

```jsx
// 모달 컴포넌트에서
useEffect(() => {
  document.body.style.cssText = `position: fixed; top: -${window.scrollY}px`;
  return () => {
    const scrollY = document.body.style.top;
    document.body.style.cssText = `position: ""; top: "";`;
    window.scrollTo(0, parseInt(scrollY || '0') * -1);
  };
}, []);
```

위와같은 내용을 정의해주면 모달이 켜질때 해당 함수가 실행되는데 뒤의 배경이 스크롤이 되지도 않을뿐더러 모달이 꺼졌을때에도 원래 스크롤 포지션을 유지해준다. 완벽한 솔루션이였다.  
참고: https://medium.com/@bestseob93/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%AA%A8%EB%8B%AC-react-modal-%EB%A7%8C%EB%93%A4%EA%B8%B0-bd003458e9d

## ref와 옵저버

intersection observer를 요소에 등록하기 위해 해당 요소의 DOM에 접근해야했고 ref를 사용해야 했다. 다중 ref를 만들어줘야했고 전에 정리한 내용대로 정리했찌만 적용이 잘 안되었다.

```jsx
const [state, setState] = useState([])

useEffect(
... api 요청
)

const refs = useRef(state.map(createRef))

useEffect(
... refs 관찰자 등록
, [refs])
```

이런식으로 구현을 했는데 데이터 요청 전 refs가 비어있기에 데이터 요청 후 다시 읽어도 refs가 채워지지 않았다. (100%는 아니고 거의 확실한 내 추측) 간단하게 생각해서 그렇다면 조건을 걸어서 조건을 주고 데이터가 있을때만 해당 코드를 실행시키려 하였다.

```jsx
const [state, setState] = useState(null)

useEffect(
... api 요청
)


if (state)
const refs = useRef(state.map(createRef))

useEffect(
... refs 관찰자 등록
, [refs])
```

안되더라 훅을 사용할땐 최상단에서 사용하라 뭐 이런 내용의 에러가 나오고 조건안에서 사용하지 말라고 한다. 그외 비슷한 이것저것 방법을 시도했다. 똑같은 화면만 몇시간동안 보면서 계속 시도해보았지만 다 안되었다 너무 스트레스 받고 힘들었따 하루종일 문제해결을 못했다. 이해는 둘쨰치고 구현자체가 안되니 머리아팠다. 그냥 이것저것 다 쑤셔넣어보자 마음먹고 그러기 시작했다.

```jsx
// const refs: any = React.useRef((list as any[]).map(React.createRef));
const refs: any = useRef([]);
// const refs: any = [];

useEffect(() => {
  console.log(refs);
}, [refs]);

useEffect(() => {
  console.log(list);
//  refs.current = refs.current.slice(0, list.length);
  registerObserver(refs);
}, [list]);


return (
...
          {(list as any[]).slice(0, 10).map((el, index) => {
            return (
              <li
                // ref={(els) => (refs[index] = els)}
                ref={(el) => (refs.current[index] = el)}
                /*

```

확실히 기억에 남는 하나는 요즘엔 16.3 이후부터 createRef()를 해서 변수에 담고 그 변수를 요소에 지정해서 레프를 달고 이전에는 ref를 만들어서 콜백으로 세부적으로 레프를 담아주었던것. 이건 기억에 남는다.  
아직 구현이 다 된건 아니지만 주석 되어있는 부분중 refs = [] 빈배열로 해놓고 채워넣는 방식은 작동은 되나 관찰자 함수가 자꾸 2번이나 실행이 되었고 위와같이 하니 일단은 정상작동 하는것처럼 보인다. 왜 이거는 되고 전 방식은 안되는지 아직 모르겠다 많이 부족하다.

## 모바일에서 input 텍스트입력기 입력 후 안보이게 하기

생각하지 못했던 부분. 모바일 에서는 키보드가 따로 없기에 input요소에서 텍스트 입력기가 나온다. 입력을 하고나서 자연스레 입력기가 사라지지 않았다. 그에 방법을 찾아보았다.

### elementRef.current.remove()

그러다가 요소 remove를 찾게되었다. 적용 예시

```jsx
...
const inputRef = useRef(null)
...
  <form
    onSubmit={(e) => {
        e.preventDefault();
        ... 제출함수
        inputRef.current.remove();
      }
    }}
  >
  ...
      <input
        type="search"
        ref={(el) => (inputRef.current = el)}
        onChange={(e) => {
          setValue(e.target.value);
        }}
      />

      ...
```

인풋 요소에 ref를 달아주고 form 제출 시 해당 요소를 ref.current.remove() 해주니 입력기가 사라졌다. 근데 요소 자체가 사라지기때문에 입력기가 사라진것... 요소는 유지하며 입력기만 안보이게 해야했다. remove는 요소를 없앨 상황에 활용하면 될것같다.

### elementRef.current.blur()

그러다가 다른 방안을 찾아보는데 blur라는 기능이 있더라. 이런 모바일 기능은 웹 개발 작업에서 확인할 수 없어서 까다로웠는데 적용해보기로 하였다.

```jsx
...
const inputRef = useRef(null)
...
  <form
    onSubmit={(e) => {
        e.preventDefault();
        ... 제출함수
        inputRef.current.blur();
      }
    }}
  >
  ...
      <input
        type="search"
        ref={(el) => (inputRef.current = el)}
        onChange={(e) => {
          setValue(e.target.value);
        }}
      />

      ...
```

요소에 blur를 적용하니 제출 후 입력기가 사라졌다. 잘 활용할 수 있을것 같다.

## includes() 메소드

유용한 메소드. includes메소드는 한마디로 배열이 특정 요소를 포함하고 있는지 판별한다. 사용법은 다음과 같다.

```js
const arr = [1, 2, 3, 4, 5];

arr.includes(1); // true

arr.includes(2); // true

arr.includes(6); // false
```

위처럼 배열에 해당 요소가 있는지 없는지 확인한 후 boolean값을 반환한다. 배열 안에 숫자요소 뿐 아니라 문자열 요소도 찾아준다.

```js
const arr = ['ho', 'hi', 'kiki'];

arr.includes('ho'); // true

arr.includes('kiki'); // true

arr.includes('ayo'); // false
```

여기서 생기는 궁금증 유사배열 요소에서는 ???

```js
const stringArr = 'abc';

stringArr.includes('a'); // true

stringArr.includes('b'); // true

stringArr.includes(''); // true

stringArr.includes('f'); // false
```

똑같이 작동하며 ''에도 true값을 반환하는것을 확인할 수 있다. includes함수를 적재적소에 잘 활용하면 좋을 것 같다.

## .env파일 환경변수 접근

보통 프로젝트에서 .env파일에 환경별로 셋팅값에 따라 값을 활용하는데 이번에 그 값을 가져와 적용해 보았다.  
처음에는 어떻게 접근해야하는지 난해하여 알아보았는데 찾아보니 많이 보던 경로로 접근을 한다. env파일에 접근을 할때에는 process.env 객체를 활용하여 해당 변수에 접근을한다.

```js
//.env
MY_VAR = 1234
YOUR_VAR = 5678

...

// .js
console.log(process.env) // {}
```

처음에 process.env파일에 콘솔을 찍어보니 그냥 빈객체만 나와서 당황스러웠다. 이부분은 webpack설정에 플러그인을 통하여 보이게 할 수 있다고 한다.
