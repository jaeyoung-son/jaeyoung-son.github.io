---
title: '배움 정리하기'
date: '2020-05-05T12:10:32.169Z'
template: 'post'
draft: false
slug: '/posts/learned_5-05/'
category: 'learn'
description: '배움 정리 하기'
tags:
  - 'learn'
---

## 그날그날 배운것들을 기록하자.

## 스크롤바 없애기

보통 웹에서 특정 설정을 해주지 않으면 내용물이 뷰포트 크기를 넘을떄 스크롤이 생긴다 세로로 넘으면 세로스크롤, 가로로 넘기면 가로스크롤이 생긴다. 때에따라서 이 스크롤바를 보여주고싶지 않을 떄가 있다.  
몇가지 css를 적용해주면 스크롤바를 숨길 수 있다.

```css
.box {
  -ms-overflow-style: none; /* IE 와 Edge */
  scrollbar-width: none; /* firefox */
}

.box::-webkit-scrollbar {
  display: none; /* chrome, safari, opera */
}
```

브라우저별 셋팅이 조금씩 다르니 참고해야한다.

## 스크롤 이벤트시 쓰로틀 적용

스크롤이벤트를 적용하면 사용자가 스크롤을 할때마다 감지되고 실행이 된다. 단순 콘솔로그만 찍어도 콘솔이 어마어마하게 많이 실행되는것을 알 수 있다. 스크롤 감지 자체가 큰 부담이 아니라고는 하지만 나름 줄여줄 수 있으면 깔끔하게 적용해보려고 하였다.  
보통 throttle과 debounce를 이용하여 시간이 지남에 따라 함수를 몇번 실행할지 제어하는데 두개는 차이를 가지고있다.

### 디바운스

디바운스는 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 것 즉, 순차적 호출을 하나의 그룹으로 그룹화 한다. 연이어 호출되는 함수중 가장 마지막이나 가장 처음만 호출하도록 하는것.

### 쓰로틀

쓰로틀은 이벤트를 일정한 주기마다 발생하도록 하는것 쓰로틀에 설정시간으로 1s를 주면 해당 이벤트는 1s동안은 한번만 실행된다.  
쓰로틀을 적용해보기로하고 쓰로틀 함수를 정의해줬다

```js
export default function throttle(fn, delay) {
    let timer;
    return function () {
    if (!timer) {
    timer = setTimeout (function () {
        timer = null;
        fn.apply(this, arguments);
        },delay)
    }
}
```

쓰로틀 이라는 함수에서 인자로 함수와 딜레이시간을 받는다. 그리고 타이머 변수를 하나 선언하고 쓰로틀 함수는 함수를 리턴하는데 그 함수는 타이머를 !timer 조건이 맞을 때 타이머를 setTimeout으로 함수를 넣어주고 그 함수 내부에서 timer = null이며 쓰로틀함수에서 인자로 받은 함수를 apply로 호출하고 셋타임아웃의 딜레이시간은 쓰로틀 함수에서 인자로 받은 시간이다. apply호출 같은경우 this를 공부할때 this를 어떻게 적용시킬지 호출단계에서 정해주는 느낌으로 받아들였는데 완전히 이해하지 않았다. 이렇게 쓰로틀 함수를 뺴놓고 사용할곳에서 import 해주고 사용한다

```jsx
import throttle from '../throttle'

const scrollEvent = ....

window.addEventListener('scroll', throttle(scrollEvent, 1000))
// 스크롤 이벤트를 scrollEvent라는 함수를 걸어주고 그 함수는 1초마다 한번 실행

```

이렇게 하면 콘솔을 찍어도 전처럼 마구마구 찍히지 않는것을 확인할 수 있다.

## 웹팩 빌드 시 dist폴더에서 디렉토리 적용

웹팩 빌드를 할 때 dist폴더에 js파일과 css파일을 빌드하는데 js파일은 js디렉토리에 들어간다음 그안에서 빌드가 되었는데 css파일은 바로 dist폴더에서 빌드가 되었다.

```
- dist
-- a.css
-- b.css
-- js
--- a.js
--- b. js
```

기존의 세팅

```js
{
loader: MiniCssExtractPlugin.loader,
options: {
    publickPath: '/app/dist/css/'
}
... 나머지 css로더들

plugins: [
new MiniCssExtractPlugin({
filename: '[name].css'
})
]
}
```

일단 셋팅에서 엔트리포인트가 한개가 아닌 두개여서 헷갈리는 부분이 많았고 아웃풋 셋팅에서 js파일들은 잘 js디렉토리를 바라보고 있길래 잘 들어갈줄알았지만 그러지 않았다. 그러다가 아웃풋에서 js 파일들을 어떻게 뱉는지 보았더니

```js
output: {
filename: 'js/[name].bundle.js'
...
}
```

파일네임 앞에 js/ 가 있고 그리고 js디렉토리 안에 빌드가 되었다 혹시나 MiniCssExtractPlugin에서도 적용을 시키면 잘될까 확인을 해보았다.  
세팅 후

```
{
loader: MiniCssExtractPlugin.loader,
options: {
    publickPath: '/app/dist/css/'
}
... 나머지 css로더들

plugins: [
new MiniCssExtractPlugin({
filename: 'css/[name].css'
})
]
```

그러니 이제 css파일들이 dist/css/a.css 이렇게 css디렉토리에 들어간것을 확인할 수 있었다,

## 모바일 기기로 접속 시 스크롤 튕김 현상

모바일뷰를 작업할떄애는 보통 크롬에서 개발자도구를 켜고 작업을 한다. 그래서 아무런 문제가 없음을 확인하며 작업을 진행했었는데 실제 모바일 디바이스로 체크를 해보니 스크롤할때마다 중간중간에 잠긴것처럼 튕기고 스크롤이 안될때가 있었다. 그래서 처음에는 스크롤이벤트에 걸려있는 내용이 문젠줄 알았었는데 이벤트 내용을 살펴보아도 원인을 찾기 어려웠다. 그러던중 맥과 아이폰을 연결하고 모바일사파리 화면에서 보고있을떄 맥사파리에서 개발자도구로 요소검사를 할 수 있다는 것을 알게되어서 그렇게 체크를 해보았다. 그래서 이 요소 저 요소 만지고있었는데 최상단 div에

```css
.main {
  overflow-x: hidden;
}
```

이 걸려있던것을 지웠더니 정상적으로 작동되는것을 확인하였다. 사파리 연동 요소검사를 잘 활용해야겠다.

## 스크롤탑 smooth가 안먹던 현상

버튼 클릭시 스크롤을 최상단으로 올려주는 이벤트가 있었는데 자바스크립트 scrollTo()함수를 사용하여 옵션으로 smooth를 주고 서서히 올라가게 기능을 짰다. 이 역시 크롬에서 개발자도구로 확인할떄 아무 문제없이 잘 되었었는데, ios기기에서 버튼을 클릭했을 때, smooth없이 그냥 다이렉트로 한번에 화면전환이 되었다.  
안드로이드기기에서 체크해보니 또 안드로이드에서는 잘 작동하였다. 어찌 ios에서도 적용할지 고민해보다가 react-scroll 라이브러리를 써서 윈도우 이벤트가아닌 라이브러리로 이벤트를 구현해보았고, 라이브러리의 애니메이션을 활용하였다.

```jsx
import { animationScroll } from 'react-scroll';

const scrollTop = () => {
  animation.scrollToTop();
};
```

그랬더니 적용 후 아이폰에서도 smooth 애니메이션이 잘 적용되었다.

## in 문법

이번에 새로 알게된 자바스크립트의 신기한 문법중 하나가 in 문법이다. 배열안에 요소가 존재하는지 boolean값으로 반환하는 것인데 다음과 같다

```js
item in arr;
// 아이템이 arr에 있다면 true 없다면 false
```

적용 한다면 다음과 같다

```js
const arr = [1, 2, 3, 4, 5];

console.log(1 in arr); // true
console.log(6 in arr); // false
```

유용하게 사용할 수 있는 것 같아서 기억해두고 필요 시 사용해야겠다.

## 공통로직 함수 처리

로딩 처리 관련해서 ptr과 연동하면서 공통 로직이 생겼는데, 페이지가 첫 마운트시 api요청을 하게되면 로딩상태를 true로 바꾸고, api요청이 끝나면 false로 바꾸어 첫마운트시 로딩 컴포넌트를 렌더링하고 그 후 타 컴포넌트를 렌더링 했다. 그리고 ptr기능을 적용하며 ptr시 api요청을 해야하는데 그 떈 로딩상태를 핸들링 할 필요가 없었는데 로딩상태만 다를 뿐 요청 로직은 같은데 처음엔 함수 2개를 작성했다.

```jsx
useEffect(() => {
 const func = async () => {
   setLoading(true)

   try {
     ...
   } catch(e) {
     ...
   }
   setLoading(false)
 }
},[])

.....

onRefresh = async () => {
   try {
     ...
   } catch(e) {
     ...
   }
 }
```

따로 빼서 정의를 하려 했는데 처음에는 같은 로직을 다른 상황에 어떻게 적용할지 난해했는데 조금 고민을해보니 자주 사용하던 방법이고, 간단한 문제였다 함수에 매개변수를 넘겨주어 refresh함수인지 마운트 함수인지 구분을 줬다.

```jsx
const setList = async (loading) => {
  if (loading) {
    setLoading(true)
  }
   try {
     ...
   } catch(e) {
     ...
   }
   if (loading) {
     setLoading(false)
   }
}
...
useEffect(() => {
  setList(true)
})
...
const onRefresh = () => {
  setList(false)
}
```

더 효율적인 방법은 차차 고민해봐야겠다.

## pull to refresh

보통 어플리케이션의 최상단에서 위로 쭉 드래그를 하면 새로고침이 되면서 데이터를 새로 불러오는 기능들이 있다.
예를들어 유튜브나 인스타그램을보면 최상단에서 위로 드래그 시 피드들이 새로 업데이트가 되고 내용이 바뀐다.
처음에는 단순히 스크롤포지션이 0이하로 떨어질때 이벤트를 걸어주면 된다고 생각했는데 아무 기능 없을떄 위로 스크롤이 안되었고 난해했다. 그래서 몇가지 라이브러리를 알아보던 중 react-simple-pull-to-refresh라는 라이브러리가 있어서 적용을 해보았다.

```jsx
import PullToRefresh from 'react-simple-pull-to-refresh'

const app = () => {
  ...
  return (
    <PullToRefresh
      onRefresh={onRefresh}
      refreshingContent={jsx element}
      maxPullDownDistance={number}
    >
      {children}
    </PullToRefresh>
  )
}
```

PullToRefresh컴포넌트 아래 칠드런으로 요소들이 들어가면 최상단에서 그 요소들이 드래깅 되었을때 특정 함수를 실행 시킬 수 있으며 그때 UI를 처리할 수 있다.
onRefresh속성 같은 경우에는 드래깅 시 처리되는 함수이다. refreshingContent는 드래깅시 보여줄 jsx요소이다.
maxPullDistance는 얼만큼 드래깅이 될지 상한치를 정해주는 속성이다.
더 다양한 속성들은  
https://www.npmjs.com/package/react-simple-pull-to-refresh

## 로딩 컴포넌트 처리 시 마운트 두번 되는 에러

위에서 정리한 로딩 관련한 문제였는데 메인 컴포넌트 밑 자식 컴포넌트에서 상태값 관리를 하는데 갑자기 언마운트 된 요소에서 상태값을 변경하려고 한다는 에러를 뱉어서 확인해보았다. 그랬더니 자식 컴포넌트에서 마운트 시 콘솔을 찍어보니 2번이 찍혔다

```
자식 마운트
부모 마운트
자식 마운트
```

부모의 구조는 다음과 같았다.

```jsx
const parent = () => {
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    setLoadnig(true)
    ... api 요청
    setLoading(false)
  })

  return loading ? (로딩요소) : (자식 컴포넌트)
}
```

처음에 원인을 찾지 못해서 답답했다. 그냥 조건부렌더링을 지우면 1번만 마운트되고 삼항연산자를 넣으면 2번을 했는데 생각해보니 굉장히 단순한 문제였다 첫 로딩값이 false이기에 처음 마운트 후 호출되는 유즈이펙트 전에 이미 로딩 상태값이 false인 상태로 자식이 마운트가 된다. 그리고 유즈이펙트에서 상태값 변경 후 언마운트 되었다가 다시 마운트가 되기에 총 2번이 되었던것. 일단 해결책은 첫 로딩값이 true이면 한번만 마운트된다.
로딩 자체를 false로 관리하고 껐다켰다 하려면 조건을 하나 더 추가해주었다.

```jsx
const parent = () => {
  const [loading, setLoading] = useState(false)
  cpnst [list, setList] = useState(null)
  useEffect(() => {
    setLoadnig(true)

    ..api요청
    setList(list)

    setLoading(false)
  })

  if (loading) return 로딩요소

  if (!list) return null

  return 자식 요소들
}
```

위와같이 조건을 하나 더 걸어주고 해결할 수 있다.

## 트랜스폼 과 fixed

이번에 ptr을 처리하면서 알게된 사실이다. 적용했던 ptr라이브러리가 자식 요소들이 transform으로 드래깅 시 위치가 조정되는 원리였다. 그래서 position:fixed 인 요소가 있었는데 fix가 되지 않았다. 알아보니 트랜스폼과 fixed가 함꼐사용되면 픽스가 되지않는다고 한다. 그래서 처음에는 당황했지만 ptr요소에서 position:fixed 속성을 가진 요소를 제거하고 밖으로 빼냈다.

## last child 처리

last child 처리관련 새로 알게된 사실. 한 컴포넌트에 이미지 요소들이 있을때 다 공통적으로 마진을 주는데 마지막 요소에 넣지않고 싶을때가 있다. 그래서 처음에는 자바스크립트와 연동해서 map함수로 요소들을 배치하는데 index값이 마지막이거나 요소가 마지막요소일떄 다른 클래스값을 부여하는 방법을 했다. 그런데 생각해보니 그때마다 이 방법을 적용하면 비효율적이라 생각했고 분명 css에서 처리할 방법이 있다고 생각했다.

```css
li:not(:last-child) {
  margin: 10px;
}
```

이렇게 not선택자에last-child를 넣어주면 li 요소중 마지막 차일드 요소를 제외하고 마진이 10애 들어가게 된다.
꼭 last-child가 아니라 first-child도 가능하다 이것을 알게되고 기본이 굉장히 부족하다고 느꼈다 css에 분명히 소흘했는데 앞으로 컴포넌트 작성할때 이러한 방법들을 더 알아보며 기본기를 탄탄히 쌓아야겠다.

## 이미지 넓이 높이 같은 값

레이아웃 작업을 하던 중 화면 너비에따라 이미지 요소들의 크기가 정해지고 높이도 그 너비에 맞게 같은 값을 주고싶었는데 그게 잘 안되었다. 정사각형 카드를 만들기 위해서 이것저것 시도를 해보았지만 어려움이 있었다. 그러다가 찾게된 방법이다.

```css
.list {
  width: calc(100% - px);
}

.box {
  position: relative;
}

.box:after {
  content: '';
  display: inline-block;
  vertical-align: top;
  width: 100%;
  height: 0;
  padding-top: 100%;
}
.card {
  position: absolute;
  top: 0;
  height: 100%;
  width: 100%;
}
```

각각의 요소들에 list클래스에서 정의한 너비가 들어가고 높이도 같은값을 가지게 하기 위함이었는데 저렇게 선택자 after속성을 주고 다음과 같은 내용을 정의하니 너비와 높이가 같은값이 맞춰졌다.

```html
<li class="list">
  <div class="box">
    <img src="" class="card" />
  </div>
</li>
```

html구조는 위와 같다.

## ts-ignore

ts-ignore 관련해서 가끔 프로젝트 작업을 하다보면 eslint-ignore를 적용할 때가 있었는데 ts에서 ts-ignore도 적용할 일이 있었다

```jsx
data.map(el => <div data={el.data} />);
```

이런식으로 태그에 속성으로 데이터를 넣어줄일이 있었는데 자꾸 ts에서 없는 속성값을 할당할 수 없다고 에러를 뱉었다 그러다가 eslint처럼 ts도 이그노어를 적용할 수 있겠다 싶어서 찾아보게 되었다.

```
{/*
  // @ts-ignore */}
```

이렇게 무시해야할 코드 위에 위와같은 코드를 작성하게 되면 에러를 뱉지 않는다 들여쓰기는 맞춰서 작성해야한다. 한줄로 작성하게되면 적용이 되지 않는다. 따라서 위와같이 ts-ignore를 적용할 수 있다.

## ripple 이벤트

material-ui나 여타 스타일 프레임워크를 보면 클릭할때 물결이 나오면서 애니메이션이 적용되는 것들이 있다. 알아보니 이런 애니메이션을 ripple이라고 하더라. 처음에는 어떤식으로 작동하는지 알아보았다.
ripple의 원리는 클릭이 발생하면 해당 클릭한부분을 rect()로 감지해서 알고 요소 하나를 생성해서 absolute로 포지션속성을 잡고 감지한 지점으로 top과 left값을 준다 그리고 퍼져나가게끔 애니메이션을 적용한뒤 overflow hidden으로 흘러넘치는것을 잡는다.

```js
Array.from(document.querySelectorAll('.ripple')).forEach(a => {
  a.addEventListener('click', function(e) {
    const ripple = document.createElement('div'),
      rect = a.getBoundingClientRect();
    (ripple.className = 'animate'),
      (ripple.style.left = `${e.x - rect.left}px`),
      (ripple.style.top = `${e.y - rect.top}px`),
      (ripple.style.background = `#${
        a.dataset.color !== undefined ? a.dataset.color : 'red'
      }`),
      ripple.style.setProperty('--material-scale', a.offsetWidth),
      a.append(ripple),
      setTimeout(function() {
        ripple.parentNode.removeChild(ripple);
      }, 500);
  });
});
```

이런식으로 적용을 해주더라.
위와같은 애니메이션을 편하게 적용할 수 있게 react-ripples라는 라이브러리가 있다.
