---
title: 'learn learn learn'
date: '2020-06-258T12:10:32.169Z'
template: 'post'
draft: false
slug: '/posts/learn_20_7_20/'
category: 'optionalChaining'
description: 'learn learn 옵셔널체이닝'
tags:
  - 'optionalChaining'
---

## 이미지 로딩 실패시 ??

개발하다보면 이미지에 데이터를 불러와서 바인딩 해줄때, 데이터가 잘못되었거나 변경되었을 경우에는 이미지가 로드되지 않거나, alt속성에 따라 엑박 이미지가 나오게 된다. 그렇게되면 UI를 해칠 우려가 있다.

### img tag onerror

이미지 태그에는 onerror라는 속성이 있다. src에 해당하는 속성으로 이미지를 불러오고, 문제가 생기면 onerror에 이미지로 대체한다.

```jsx
import React from 'react
import errImg from './'
import replaceImg from './'

const ImgReplace = () => {

return <img src={errImg} onError={replaceImg} />

}
```

위와 같이 적용해 주었을 경우에는 errImg를 불러오는데 실패하면 replaceImg로 대체하여 로드한다.

### background Img

위의 경우에는 이미지 태그에서 적용이 가능하나 백그라운드 이미지로 적용할 경우 적용이 안된다. 그러나 백그라운드 이미지에서도 간단한 방법이 있다.

```jsx
import React from 'react
import errImg from './'
import replaceImg from './'

const ImgReplace = () => {

return <div
style={{
backgroundImg: 'url(errImg), url(replaceImg)'
}}
/>

}
```

background-img 속성에 url(이미지)를 2개를 넣어준다 먼저 앞에 이미지를 불러오고 실패 했을때 뒤에있는 이미지를 불러온다. 이렇게 이미지 로드시 실패에 관한 상황에 대처할 수 있다.

## 웹폰트 관련내용

웹폰트는 글라프로 구성된 모음이며, 각 글라프는 문자나 기호를 설명하는 벡터 모양이다. 그 결과, 두 가지 단순한 변수가 특정 글꼴 파일의 크기를 결정하며 Open Sans라는 인기있는 웹폰트에는 라틴어 그리스어 및 키릴어 문자를 포함하는 897개의 글라프가 들어있다.

### 폰트

- web safe font- 일반적으로 시스템에 설치된 폰트이며 다운로드 없이 사용자에게 의도대로 표현이 가능하다.(Arial, Helvetica)
- web font - 설치되어 있지 않아서 브라우저에서 다운로드 해야하는 폰트

### 왜 웹폰트가 나온걸까?

- 시스템에 폰트가 없다면 폰트를 보여줄 수 없다.
- 디자이너의 의도대로 표현이 안된다.
- 가독성
- 한국어는 특히, web safe font로 한계가 있다.

### 웹폰트의 형식

오늘날 웹에서는 네 가지 글꼴 컨테이너 형식인 EOT,TTF,WOFF,WOFF2가 사용된다. 여러 옵션이 있지만, 이전
브라우저와 최신 브라우저 모두에서 작동하는 단일 범용 형식은 없다. EOT는 IE 전용이고, TTF는 부분적인 IE
지원 기능이 포함되어있고, WOFF는 지원 범위가 가장 넓지만 몇명 이전 브라우저에서는 사용할 수 없다.
WOFF2.0지원은 많은 브라우저에서 현재 진행중이다.

- EOT: IE8 이하일 경우
- TTF: 구형 안드로이드버전(4.4)에서 필요.
- WOFF: 대부분의 모던 브라우저에서 지원
- WOFF2: WOFF보다 압축률이 30%정도 더 좋음

### 웹폰트의 문제점?

단순하게 다운로드 시간만큼 렌더링이 느려진다. 특히 한글 폰트는 상대적으로 용량이 크다. 이점이 여려 문제를 야기한다.

### 적용

- font-family 속성으로 폰트를 적용한다.
- font-family에 명시된 글꼴이 설치가 되어있지 않다면 기본 글꼴을 보여준다.

```css
body {
font-family: 'Nanim Gothic', sans-serif";
}
```

### @font-face

```css
@font-face {
  font-family: 'Nanum Gothic';
  font-style: normal;
  font-weight: 400;
  src: url(/font/NanumGothic.eot), url(....woff2) format('woff2'), url(....woff)
      format('woff'), url(....ttf) format('truetype') ...;
}
```

### 확장자를 적용할 때 순서

1. woff2를 가장 앞에 써준다. 브라우저는 선언된 순서대로 지원 가능한 파일 형식을 다운받기에 압축률이 가장 좋은 woff2를 먼저 선언한다.
2. format()은 반드시 써준다. 쓰지 않으면 브라우저는 지원 가능한 파일 형식이 나올 때 까지 순서대로 받음

### 적용 시 local 속성 세팅

local 없이 선언하게 되면 폰트 존재 유무와 관계없이 무조건 다운받게된다. 따라서 불필요한 리소스를 요청하게
된다.
local 문법을 선언해주면 시스템에설치 되어 있다면 리소스를 요청하지 않는다.

```css
src: local('Nanum-Gothic'), url(/font/NanumGothic.eot),
  url(....woff2) format('woff2'), url(....woff) format('woff'),
  url(....ttf) format('truetype');
```

### subset

@font-face를 적용할때 unicode-range속성을 사용해서 지원가능한 unicode범위를 정해놓고 해당 속성에
일치하는 글자를 렌더링할 때 다운받는다.

```css
@font-face {
  ... unicode-range: U+x xxx-xxxx, u+x xxx-xxxx;
}
```

다국어를 지원하는 사이트의 경우 유용하다.

### FOIT과 FOUT

- FOIT: Flash of Invisible Text
  웹폰트가 로드될 떄까지 텍스트를 렌더링 하지 않다가 로드가 된 이후에 텍스트를 보여주는 동작.  
  폰트가 로딩되지 않으면 웹페이지의 블락을 가져옴, 모던브라우저는 기다리는 제한 시간이 있다.  
  chrome,safari, firefox

- FOUT: Flash of Unstyled Tecxt
  웹폰트가 로드될떄까지 기본 폰트를 보여주고 이후 글꼴을 대체하는 방식.
  흔히 말하는 깜빡임이며 폰트에따라 자간, 높이에 따라 레이아웃이 변경될 수 있다.

### 왜??

폰트를 받는 시점이 텍스트를 렌더링 하는 시점과 경합이 일어나기에 그렇다. 두 가지 문제를 최소화 하는게 중요 FOIT을 방지하고 FOUT를 최소화 하는 방법으로!

### font-display

@font-face에서 font-display라는 속성이 있다. 값들은 다음과 같다.

- auto: 브라우저의 기본동작에 맡기는 방식
- block: 짧은 차단 기간과 무한 스왑 기간을 부여한다. 글꼴이 로드되지 않으면 브라우저가 처음에 보이지 않는 텍스트를 그리지만, 로드되는 즉시 글꼴로 스왑한다.
- swap: 글꼴에 0초의 차단 기간과 무한 스왑 기간을 부여한다. 응답이 올 떄까지 기다리고 그전까지 기본 폰트를 보여줌
- fallback: 100ms 내외의 시간 동안만 블락하고 기본폰트를 보여준다. 응답이 오면 해당 폰트로 스왑하나 3s만 기다림.
- optional: 100ms 내외의 시간동안만 블락하고 기본폰트를 보여줌 그 후 대체하지 않는다.

### 자바스크립트를 활용한 예

```js
async function fontLoad() {
  const font = new FontFace('font', 'url(font.woff)');
  await font.load();

  document.fonts.add(font);
  document.body.classList.add('fonts-loaded');
}
```

위의 예처럼 className을 핸들링 할 수 도 있겠고, 다른 방법을 사용할 수 도 있겠다. 폰트 로딩 체크가 가능하다는점.

### preload

html 의 head 부분에 link 태그를 추가한다.

```html
<link rel="preload" href="./fonts/..." as="font" ... />
```

preload를 이용해서 폰트를 받으면 리소스를 다른것보다 먼저 요청한다. 요소들이 그려지기 전에 로드를 하고 FOUT과 FOIT이 없어지는 대신, 그만큼 렌더링이 느려진다. 사용여부와 관계없이 무조간 리소스를 받는다.  
내가 preload를 이번에 적용하려고 할때 잘 적용이 되지 않았다. 원인은 아직 찾지 못했고 더 학습해야할 부분이다.  
대부분의 경우에 preload와 font-display를 활용해서 대처가 가능하고 좀더 세부적인 컨트롤이 필요할 때 JS를 사용해서 적용해주면 될 것 같다.

Noto Sans 관련 https://m.blog.naver.com/PostView.nhn?blogId=flyteen85&logNo=221330192231&proxyReferer=https:%2F%2Fwww.google.com%2F

## Webpack dotenv

환경변수를 관리할때 프로젝트의 루트 디렉토리에 .env 파일에 환경변수들을 관리하고 사용을 하며 그 내용을
간략하게 한번 정리했다. 신규 프로젝트를 생성해서 process.env에 접근을 했더니 접근이 되지 않았다.
해당 내용을 알아보니 webpack 세팅을 별도로 해주어야 했다. dotenv-webpack을 먼저 받는다.

```
$ npm i dotenv-webpack
```

그 후 webpack.config.js에서 셋팅을 해준다.

```js
const Dotenv = require('dotenv-webpack')
//.. 그 후 플러그인 추가
module.export = {
...
plugins: [
new Dotenv({
path: '/.env',
// ... 나머지 옵션들
})
]
...
}
```

위와같이 웹팩 적용 후 다시 process.env에 접근하면 환경변수에 접근이 가능한것을 확인할 수 있다.
