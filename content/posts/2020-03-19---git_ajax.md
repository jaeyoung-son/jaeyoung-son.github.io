---
title: '깃에 관하여'
date: '2020-03-19T12:10:32.169Z'
template: 'post'
draft: false
slug: '/posts/git/'
category: 'git'
description: '깃 내용 정리'
tags:
  - 'git'
---

깃을 사용하는 이유 ?? 협업에 매우 좋기 때문. 깃에 관하여

## git merge

머지란 브랜치의 변경사항의 병합(합치기)을 위해 사용하는 깃 명령어이다.  
git merge (브랜치명)  
브랜치명은 합칠 브랜치이고 바탕이되는 브랜치가 아니다.
B 브랜치를 A 브랜치로 병합(merge)할 때 (B ---> A)

```
git checkout A
git merge B
```

### merge시 메시지

- fast-foward: 빨리감기라는 뜻으로 예를들어 A브랜치에서 급하게 다른 것을 만들어보려고 B브랜치를 생성하고 B브랜치는 여러번의 commit이 있었을때, A브랜치에서 B브랜치를 merge한다고 가정하면 A브랜치에서 B브랜치를 분기해준것 외 다른 commit이 없으므로 A브랜치는 B브랜치만큼 그냥 빨리감기하면 되는 상황 별도의 commit log없이 B브랜치가 만든 최신의 commit log를 가리키게 만드는 것을 fast-foward 머지커밋(머지하며 생기는 커밋)이 생기지 않는다. 쉽게말해 머지 대상이 가장 최신일때 패스트 포워드이며 머지커밋이 남지않음.

* recursive strategy: 재귀적인 전략으로 A브랜치에서 B브랜치를 생성했다. 그 후 A브랜치도 commit이 여러번 있었고 B브랜치도 commit이 여러번 있었을 때 A브랜치에서 B브랜치를 merge하면 fast-foward할 수 없고 git은 A브랜치와 B브랜치의 조상 commit을 찾아 내부적으로 3way merge라는 방법을 이용해 merge를 한다.

## git rebase

리베이스 말그대로 즉 브랜치의 베이스를 다시 설정한다는 의미이다.

```
git checkout (기준을다시잡을브랜치) 로 이동
git rebase (어디로 기준을잡을지) 리베이스
```

또는

```
git rebase (어디로 브랜치) (어떤 브랜치)
```

어디로 브랜치와 어떤 브랜치의 공통 조상 커밋부터 어떤 브랜치까지의 모든 커밋의 base를 어디로 브랜치의 위치로 바꾸어라 라는 의미이다.  
텍스트 에디터가 열리고 커밋 내역들이 표시된다.  
변경을 하거나 스쿼시 후

```
git rebase --continue
```

머지 때와는 살짝 다르다 머지는 갈라진 두 커밋이 합쳐져서 새로운 커밋이 되었다면, 리베이스는 하나의 커밋이 다른 커밋 앞으로 올라간다.
리베이스를 사용하게되면 베이스가 다시잡히므로 두브랜치를 합치기위한 머지커밋이 생기지 않고 깔끔한 히스토리를 만들 수 있다.

### rebase시 주의점

- 이미 공개 저장소에 push한 커밋을 리베이스 하면 안된다.
  리베이스는 기존의 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 다른 커밋을 새로 만드므로 새 커밋을 서버에 push하면 동료가 push했을때 다시 merge해야 한다.

## git squash

스쿼시란 명령어는 따로 존재하지 않는다. 리베이스를 함에 있어서 여러개의 커밋을 묶을때 하나로 합칠때 스쿼시를 한다.

```
...... commit1
...... commit2
...... commit3
```

이 커밋들을 합치고자 할 때 리베이스를 하면 에디터가 나온다

```
pick ...... commit1
pick ...... commit2
pick ...... commit3
#
#
```

아래 커밋들의 pick을 squash 혹은 s 로 바꿔주기

```
pick ...... commit1
squash ...... commit2
squash ...... commit3
#
#
```

그 후 다른 vi창이 나오면서 커밋 메시지를 다시 작성 할 수 있다.

```
pick ...... **작업 완료
rebasing (3/3)
#
#
#
```

## git flow

깃플로우란? 깃을 어떻게 효율적으로 사용하느냐를 결정하는 패턴 혹은 프로세스

### master

배포가 된 코드를 마스터에 저장함 최종본 같은것. 마스터에 커밋을 하게될 경우 검증이 안된 상태로 배포를 해야하니 별도로 구분을 해줘야 한다. 배포로인해 개발 커밋이 멈추지 않을 수 있다.

### feature

기능별 단위 브랜치. 새로운 기능을 추가하기 위해 사용되는 브랜치 이며 개발자의 로컬에서 존재한다. (feature/기능이름) 으로만듬

### develop

개발 기준이 되는 브랜치. feature브랜치를 develop에서 만든다.  
여러명의 개발자가 공유하는 branch이며 개발자들이 develop에서 feature브랜치를 만들고 개발을 한 후 완료시 develop브랜치에 push나 pr을 보낸 후 merge를 한다.

### release

배포 테스트용 브랜치. 마스터는 실제 배포가된 코드가 들어가고 릴리즈는 배포후보인것, 마지막 테스트를 안한 상태이며 테스트시 버그가 생기면 릴리즈에서 고친다.

### hotfix

긴급하게고침 핫픽스를 하기위한 브랜치. 마스터를 기준으로 이미 배포된 코드에서 버그가 나오면 마스터에서 브랜치를 판다. develop브랜치에는 개발중이고 검증안된 코드가 있으므로 develop브랜치에서 만드는게 아님.

## AJAX

AJAX란? Asynchronous JavaScript And XML 의 줄임말 프로그래밍 방식이며 말 그대로 비동기 자바스크립트이다. 동시에 무언가 일어나는 것이 아니라 개발자가 원할때마다 어떤 일이 일어날 수 있도록 개발자가 지정할 수 있다. 클라이언츠와 서버간에 XML데이터를 주고받는 기술.  
ajax는 html페이지 전체가 아닌 일부만 갱신할 수 있도록 XMLHttpRequest객체를 통해 서버에 요청을 한다. 이 경우 Json이나 xml형태로 필요한 데이터만 받아 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있다.

### 장점

- 웹페이지의 속도향상
- 서버의 처리가 완료될 때까지 기다리지 않고 처리가 가능
- 서버에서 data만 전송하면 되므로 전체적인 코딩의 양이 줄어든다.
- 기존 웹에서 불가능했던 다양한 UI를 가능하게 해준다.

### 단점

- 히스토리 관리가 안됨(보안에 더 신경을 써야함)
- 연속으로 데이터를 요청하면 서버 부하가 증가할 수 있다.
- XMLHttpRequest를 통해 통신을 하는 경우 사용자에게 아무런 진행 정보가 주어지지 않는다. 아직 요쳥이 완료되지 않았는데 사용자가 페이지를 떠나거나 오작동 우려가있음.

### JSON

JSON 제이슨 JavaScript Object Notation  
프론트앤드 백앤드가 분리되어있을때 다른 언어에서 주고받는 데이터 구조를 맞추기 위해 사용하는 데이터 구조 객체와 비슷하게 생겼다.

#### JSON의 규칙

- {로시작해서 }로 끝난다.
- key는 무조건 ""쌍다옴표를 붙여줘야한다.
- value에 string이 올 경우 무조건 ""쌍따옴표를 붙여줘야한다.
- 다음 데이터가 더 있을 때만 ,comma를 붙일 수 있다.
-
